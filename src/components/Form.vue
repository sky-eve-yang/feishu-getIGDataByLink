<template>
  <!-- TITLE  -->
  <div style="width: 100%;padding-left: 10px;border-left: 5px solid #2598f8;margin-bottom: 20px;padding-top: 5px;">{{ $t('title') }}</div>
  <!-- DESCRIPTION  -->
  <el-alert  style="margin: 20px 0 0 0;color: #606266;" :title="$t('alerts.selectNumberField')" type="info" />
  <el-alert  style="margin: 10px 0 0 0;" :title="$t('alerts.error')" type="error" />
  <!-- DOCX -->
  <el-link style="color: #3e75f5;margin: 20px 0;" type="primary" :href="DESC_DOCX_URL"
  target="_blank">üëâ  {{ $t('labels.apiDocument') }}</el-link>

  
  <el-form style="color: #606266">
    <!-- INPUT-AREA  -->
    <el-form-item v-if="!(isProgressStarted && !isProgressEnded)" :label="$t('labels.headers')  " size="large" required>
      Cookie<el-input v-model="IG_COOKIE" :placeholder="$t('placeholder.cookie')" />
      X-Ig-App-ID<el-input v-model="IG_APP_ID" :placeholder="$t('placeholder.appId')" />
      X-Ig-Www-Claim<el-input v-model="IG_CLAIM" :placeholder="$t('placeholder.claim')" />

    </el-form-item>

    <el-form-item :label="$t('labels.params') " size="large" required>
      Username
      <el-select v-model="userTableId" :placeholder="$t('placeholder.userTableId')" style="width: 100%">
        <el-option v-for="meta in tableMetaList" :key="meta.id" :label="meta.name" :value="meta.id" />
      </el-select>
      <el-select v-if="userTableId" v-model="userFieldId" :placeholder="$t('placeholder.userFieldId')" style="width: 100%; margin-top: 10px;">
        <el-option v-for="meta in fieldMetaList" :key="meta.id" :label="meta.name" :value="meta.id" />
      </el-select>
      
      <!-- Hashtag<el-input v-model="targetHashTag" :placeholder="$t('placeholder.hashtag')" /> -->
    </el-form-item>

    <el-form-item :label="$t('labels.outputTable') " size="large" required>
      <el-select v-model="postTableId" :placeholder="$t('placeholder.outputTableId')" style="width: 100%">
        <el-option v-for="meta in tableMetaList" :key="meta.id" :label="meta.name" :value="meta.id" />
      </el-select>
    </el-form-item>


    <!-- CHECKBOX-AREA  -->
    <div class="map-fields-checklist">
      <el-checkbox v-model="isSelectAllFields" :indeterminate="isIndeterminateToMap" @change="handleselectAllFieldsChange">{{
        $t(`${BASE_I18N_FIELD_PATH}.selectAll`) }}</el-checkbox>
      <el-checkbox-group v-model="responseFieldsSelected" @change="handleresponseFieldsSelectedChange">
        <el-checkbox v-for="fieldToMap in responseFieldsAvaiable" :key="fieldToMap.label" :label="fieldToMap.label">
          {{ $t(`${BASE_I18N_FIELD_PATH}.${fieldToMap.label}`) }}
        </el-checkbox>
      </el-checkbox-group>
    </div>

    <!-- SUMBIT BUTTON  -->
    <el-button color="#3370ff" style="margin: 20px 0;"  type="primary" @click="handleIGRequest">{{ $t('sumbit')
    }}</el-button>    
  </el-form>

  <!-- DESCRIPTION  -->
  <div v-if="isProgressStarted" class="demo-progress" style="margin: 10px 0 20px 0;">
    <div style="font-size: 14px; margin-bottom: 4px;">{{ $t('infoTip.process') }}</div>
    <el-progress :percentage="progressPercentage" />
  </div>

  <el-alert v-if="isProgressEnded && isError"  :title="errorMsgFinal"  type="error" show-icon />
  <el-alert v-if="isProgressEnded" style="background-color: #e1eaff;color: #606266;margin-top: 20px;" :title="processResultDesc"  type="success" show-icon />
  


</template>

<script setup>
import { bitable } from '@lark-base-open/js-sdk';
import { useI18n } from 'vue-i18n';
import { ref, onMounted, watch } from 'vue';
import axios from 'axios';
import { queryBaseTableFieldsIdTargeted, updateParams, checkIfEmpty, addTableRecords } from '../utils/helper';
import { queryBaseTableAndView, queryBaseTableMetaList, queryTableAndFieldMetaTypeList, queryRecordIdList, queryFieldById  } from "../utils/base"
import { DESC_DOCX_URL, BASE_I18N_FIELD_PATH, BASE_REQUEST_URL } from '../utils/constants';



// -- ÈÖçÁΩÆÂå∫Âüü
const { t } = useI18n();  // ÂõΩÈôÖÂåñ
const IG_HEADER_STRUCTURE = {
  "cookie": "cookie",
  "appId": "app_id",
  "claim": "claim",
  "maxId": "max_id"
}

const IG_PARAMS_STRUCTURE = {
  "hashtag": "hashtag",
  "username": "user"
}


// -- Ê†∏ÂøÉÊï∞ÊçÆÂå∫Âüü
// --== ÂìçÂ∫îÂºè
const IG_COOKIE = ref("")
const IG_APP_ID = ref("")
const IG_CLAIM = ref("")

const targetHashTag = ref("")
const targetUsername = ref("")
const userTableId = ref("")
const userFieldId = ref("")
const postTableId = ref("")

const tableMetaList = ref("")
const fieldMetaList = ref("")

const responseFieldsSelected = ref([
  "postLink", "videoViewCount", "likeCount", "username", "commentCount", "createTime", "requestTime", "text"
]) //  ÂèØ‰ª•ÂàõÂª∫ÁöÑÂ≠óÊÆµ


// --== ÈùûÂìçÂ∫îÂºè


// -- ËæÖÂä©Êï∞ÊçÆÂå∫Âüü
const isProgressStarted = ref(false)
const isProgressEnded = ref(false)
const isError = ref(false)
const errorMsgFinal = ref("")
const progressPercentage = ref(1)
const processResultDesc = ref("")
const isSelectAllFields = ref(false)
const isIndeterminateToMap = ref(true)
const responseFieldsAvaiable = ref([
  {"label": "username"},
  {"label": "postLink"},
  {"label": "text"},
  {"label": "videoViewCount"},
  {"label": "likeCount"},
  {"label": "commentCount"},
  {"label": "videoLink"},
  {"label": "createTime"},
  {"label": "requestTime"}
  
])   
let postTotalNum = 0
let postNumFilteredHashtag = 0
let requestNextMaxId = ""
let uploaderNum = 0
let duration = 0

// -- ÊñπÊ≥ïÂ£∞ÊòéÔºöÂáΩÊï∞Âºè & Êü•ËØ¢Âºè

/**
 * @main {Êèí‰ª∂ËøêË°å‰∏ªÂáΩÊï∞}
 */
const handleIGRequest = async () => {
  // Ê£ÄÊü•ÂøÖÈÄâ‰ø°ÊÅØÊòØÂê¶Â∑≤Â°´ÂÜô
  const { userTableId, userFieldId, postTableId } = queryTableAndFieldSelect()

  const checkRes = await checkIfEmpty(IG_COOKIE.value, IG_APP_ID.value, IG_CLAIM.value, userTableId, userFieldId, postTableId)
  if (checkRes.isError) {
    await handleErrorTip(checkRes.errorMsg, checkRes.errorType)
    return
  }
    

  // Êèí‰ª∂ËøêË°åÂºÄÂßãÊèêÁ§∫
  await showProcessTip("start")
  

  // Êü•ËØ¢ Base SDK table„ÄÅview Á≠âÂÆû‰æãÔºåÂπ∂Ëé∑ÂèñÂΩìÂâçË°®Ê†ºÁöÑÂ≠óÊÆµÂÖÉ‰ø°ÊÅØ
  const {table, existedFieldMetaList} = await queryBaseTableAndView(postTableId)
  
  // Êü•ËØ¢ Instagram response fields selected
  const targetResponseFields = queryTargetResponseFields()
  // Êü•ËØ¢ targetResponseFields ÂØπÂ∫îÁöÑÂ§öÁª¥Ë°®Ê†ºÂ≠óÊÆµIdÔºåËã•Êó†ÔºåÂàôÂàõÂª∫
  const baseTableFieldsIdTargetedRes = await queryBaseTableFieldsIdTargeted(table, existedFieldMetaList, targetResponseFields, t)
  if (baseTableFieldsIdTargetedRes.isError) {
    await handleErrorTip(baseTableFieldsIdTargetedRes.errorMsg, baseTableFieldsIdTargetedRes.errorType)
    return
  }
  const baseTableFieldsIdTargeted = baseTableFieldsIdTargetedRes.data
  console.log("baseTableFieldsIdTargeted", baseTableFieldsIdTargeted)
  console.log(1111)


  // Êü•ËØ¢ Instagram Cookie Á≠âËØ∑Ê±ÇÂ§¥‰ø°ÊÅØ
  const headers = queryIGHeaderInput() 
  console.log(222)

  

  

  const startTime = Date.now()
  // FOR Ê†áËÆ∞ÔºöÂæ™ÁéØËØ∑Ê±ÇÈúÄË¶ÅÂ§ÑÁêÜÁöÑÁî®Êà∑ÔºåÁõ¥Âà∞Ê≤°ÊúâÁî®Êà∑
  const recordListUserTable = await queryRecordIdList(userTableId)
  const userField = await queryFieldById(userTableId, userFieldId)


  for (let recordId of recordListUserTable) {
    const usernameValue = await userField.getValue(recordId)
    if (!usernameValue)
      continue

    uploaderNum ++
    const username = usernameValue[0].text
  // Êü•ËØ¢ Instagram Hashtag Á≠âËØ∑Ê±ÇÂèÇÊï∞‰ø°ÊÅØ
    const params = queryIGParamsInput(username)

    // WHILE Ê†áËÆ∞ÔºöÂæ™ÁéØËØ∑Ê±Ç Instagram APIÔºåÁõ¥Âà∞Ê≤°ÊúâÊõ¥Â§ö Posts
    do {
      const res = await getDataAndUpdateTable(headers, params, table, baseTableFieldsIdTargeted, targetUsername.value)
      if (res.isError) {
        // Handle the error and end the function
        await handleErrorTip(res.errorMsg, "request-error")
        return
      }
      if (res.isEmpty === true)
        continue
    } while (requestNextMaxId)
    
  }
  const endTime = Date.now()
  duration = endTime - startTime
  // Êèí‰ª∂ËøêË°åÁªìÊùüÊèêÁ§∫
  await showProcessTip("end")
  
}

/**
 * Ëé∑ÂèñInstagram Áî®Êà∑ Posts Êï∞ÊçÆÔºåÂπ∂Êõ¥Êñ∞Áî®Êà∑Â§öÁª¥Ë°®Ê†ºÊï∞ÊçÆ
 * @param {object} headers ËØ∑Ê±ÇÂ§¥‰ø°ÊÅØ
 * @param {object} params ËØ∑Ê±ÇÂèÇÊï∞‰ø°ÊÅØ
 * @param {object} table Â§öÁª¥Ë°®Ê†º Table ÂÆû‰æã
 */
const getDataAndUpdateTable = async (headers, params, table, baseTableFieldsIdTargeted) => {
  // send API request
  const res = await queryIGUserPostsFilteredHashtag(headers, params)
  if (res.isError)  return { isError: true, errorMsg: res.errorMsg }
  else updateDataFromResponse(res, params)

  if (res.data.hashtag_length === 0) {
    return { isError: false, isEmpty: true }
  }
  // handle API response data to Target data structure or 
  const targetDataStructure = queryTargetDataStructure(res.data, baseTableFieldsIdTargeted, params)

  // Write the data back to the multidimensional table
  await addTableRecords(table, targetDataStructure)

  return { isError: false }
}

/**
 * @command {postTotalNum, postNumFilteredHashtag, requestNextMaxId, params} 
 * ‰æùÊçÆÊé•Âè£ËøîÂõû‰ø°ÊÅØÔºåÊõ¥Êñ∞‰∏Ä‰∫õËæÖÂä©‰ø°ÊÅØ
 * @param {object} res ÂêéÁ´ØÊé•Âè£ËøîÂõûÊï∞ÊçÆ
 * @param {object} params ËØ∑Ê±ÇÂèÇÊï∞‰ø°ÊÅØ
 */
const updateDataFromResponse = (res, params) => {
  postTotalNum += res.data.total_length
  postNumFilteredHashtag += res.data.hashtag_length
  requestNextMaxId = res.data.next_max_id
  updateParams(params, IG_HEADER_STRUCTURE["maxId"], res.data.next_max_id)
}


/**
 * @query(status) {Êèí‰ª∂ËøêË°åÁä∂ÊÄÅÈÄöÁü•}
 * @param {string} Tiptype ÊèêÁ§∫Á±ªÂûã
 */
const showProcessTip = async (Tiptype) => {
  if (Tiptype === "start") {
    progressPercentage.value = 1
    isProgressStarted.value = true
    isProgressEnded.value = false

    const interval = setInterval(() => {
      // ÈöèÊú∫Â¢ûÂä†ËøõÂ∫¶ÔºåÊ®°ÊãüÂä†ËΩΩËøáÁ®ã
      progressPercentage.value += Math.floor(Math.random() * 5) 
      if (progressPercentage.value > 90) {
        clearInterval(interval);
      }
    }, 1000); // ÊØèÁßíÊõ¥Êñ∞‰∏ÄÊ¨°ËøõÂ∫¶
    
    await bitable.ui.showToast({
      toastType: 'success',
      message: t('infoTip.start')
    })



  } else if (Tiptype === "end") {s
    let endInfo = t('infoTip.end_sentence')
    
    const minutes = Math.floor(duration / 60000);
    const seconds = Number((duration % 60000) / 1000);
    const formattedTime = ` ${minutes} min ${seconds} s`;

    const resDesc = endInfo.replace("time", formattedTime).replace("uploaderNum", uploaderNum).replace("postTotalNum", postTotalNum).replace("postNumFilteredHashtag", postNumFilteredHashtag)
    progressPercentage.value = 100
    processResultDesc.value = resDesc
    isProgressStarted.value = false
    isProgressEnded.value = true

    postTotalNum = 0
    postNumFilteredHashtag = 0
    requestNextMaxId = ""

    await bitable.ui.showToast({
      toastType: 'success',
      message: t('infoTip.end')
    })
  }
}





/** @query{ËøîÂõû Instagram Cookie Á≠âËØ∑Ê±ÇÂ§¥‰ø°ÊÅØ}
 * @return{object}
 */
const queryIGHeaderInput = () => {

  localStorage.setItem('IG_COOKIE', IG_COOKIE.value)   // string Á±ªÂûã
  localStorage.setItem('IG_APP_ID', IG_APP_ID.value)   // string Á±ªÂûã
  localStorage.setItem('IG_CLAIM', IG_CLAIM.value)   // string Á±ªÂûã
  

  return {
    [IG_HEADER_STRUCTURE.cookie]: IG_COOKIE.value,
    [IG_HEADER_STRUCTURE.appId]: IG_APP_ID.value,
    [IG_HEADER_STRUCTURE.claim]: IG_CLAIM.value
  }
}


/** @query{Êü•ËØ¢ Instagram Hashtag Á≠âËØ∑Ê±ÇÂèÇÊï∞‰ø°ÊÅØ}
 * @return{objecy}
 */
const queryIGParamsInput = (targetUsername) => {
  localStorage.setItem('targetHashTag', targetHashTag.value)   // string Á±ªÂûã
  localStorage.setItem('targetUsername', targetUsername)   // string Á±ªÂûã

  return {
    [IG_PARAMS_STRUCTURE.hashtag]: targetHashTag.value,
    [IG_PARAMS_STRUCTURE.username]: targetUsername
  }
}

/**
 * @query {Êü•ËØ¢Áî®Êà∑ÈÄâÊã©ÁöÑÊï∞ÊçÆË°®ÂíåÂ≠óÊÆµ‰ø°ÊÅØ}
 * @return {object}
 */
const queryTableAndFieldSelect = () => {
  localStorage.setItem('userTableId', userTableId.value)   // string Á±ªÂûã
  localStorage.setItem('userFieldId', userFieldId.value)   // string Á±ªÂûã
  localStorage.setItem('postTableId', postTableId.value)   // string Á±ªÂûã


  return {
    userTableId: userTableId.value, 
    userFieldId: userFieldId.value,
    postTableId: postTableId.value
  }
}


/** @query {Êü•ËØ¢ÈúÄË¶ÅËøîÂõûÁöÑ fields Êï∞ÁªÑ}
 * @return {array}
 */
const queryTargetResponseFields = () => {
  // localStorage.setItem('responseFieldsSelected', JSON.stringify(responseFieldsSelected.value))  // object Á±ªÂûã
  // localStorage.setItem('isSelectAllFields', isSelectAllFields.value)   // string Á±ªÂûã

  return responseFieldsSelected.value
}


/** @query  {sendAPI} {Êü•ËØ¢ Instagram Áî®Êà∑ÁâπÂÆö Hastag ‰∏ãÁöÑÂÖ®ÈÉ®Â∏ñÂ≠ê}
 * @param {object} headers IG ËØ∑Ê±ÇÂ§¥‰ø°ÊÅØ
 * @param {object} params IG ËØ∑Ê±ÇÂèÇÊï∞‰ø°ÊÅØ
 * @return {object} ÈÄöËøá isError Â≠óÊÆµÊ†áËÆ∞ËØ∑Ê±ÇÊòØÂê¶ÊàêÂäü
 */
const queryIGUserPostsFilteredHashtag = async (headers, params) => {
  const headersCopy = JSON.parse(JSON.stringify(headers))
  const paramsCopy = JSON.parse(JSON.stringify(params))
  headersCopy[IG_HEADER_STRUCTURE.cookie] = headersCopy[IG_HEADER_STRUCTURE.cookie].replaceAll('"', '\\"')
  
  const requestData = {...headersCopy, ...paramsCopy}

  // ÂèëÈÄÅPOSTËØ∑Ê±Ç
  try {
      const response = await axios.post(`${BASE_REQUEST_URL}/get_user_total_posts`, requestData);
      console.log('Response:', response.data);
      return { data: response.data, isError: false };
  } catch (error) {
      console.error('Error:', error);
      if (error?.response?.data?.error)
        return { errorMsg: error.response.data.error, isError: true };
      else
        return { errorMsg: error.message, isError: true };
  }
}

/**
 * @query(hanlde) {Êä•ÈîôÊèêÁ§∫ÂáΩÊï∞}
 * @param {string} errorMsg ÈîôËØØÊèêÁ§∫
 * @param {string} errorType ÈîôËØØÁ±ªÂûã
 */
const handleErrorTip = async (errorMsg, errorType) => {
  if (errorType === "request-error" || errorType === "field-type-error") {
    await bitable.ui.showToast({
      toastType: 'error',
      message: errorMsg
    })
  }

  else {
    await bitable.ui.showToast({
      toastType: 'error',
      message: t(`errorTip.${errorType}`)
    })
  }
  isError.value = true
  errorMsgFinal.value = errorMsg
  await showProcessTip("end")
}

/**
 * @query {Ëé∑ÂèñÊ†ºÂºèÂåñÁöÑ fieldId-value Êï∞ÊçÆ}
 * @param {object} response Êé•Âè£ËøîÂõûÁöÑ IG Êï∞ÊçÆ
 * @param {object} baseTableFieldsIdTargeted simplyName-fieldId
 * @return {array} Ê†ºÂºèÂåñÁöÑ fieldId-value Êï∞ÊçÆ
 */
const queryTargetDataStructure = (response, baseTableFieldsIdTargeted, params) => {
  const data = JSON.parse(JSON.stringify(response.res))
  const fieldIdObj = JSON.parse(JSON.stringify(baseTableFieldsIdTargeted))
  const mapRelationship = {
    "postLink": "code",
    "videoViewCount": "video_view_count",
    "likeCount": "like_count",
    "commentCount": "comment_count",
    "createTime": "created_at",
    "text": "text",
    "videoLink": "video",
  }
  let list = []

  for (let i = 0; i < data.length; i++) {
    let obj = {}
    for (let key in fieldIdObj) {
      if (key === "requestTime") {
        const now = new Date();
        obj[fieldIdObj[key]] = now.getTime();
        continue
      }

      let value = data[i][mapRelationship[key]]

      if (key === "postLink") 
        value = "https://www.instagram.com/p/" + value
      else if (key === "createTime")
        value = value*1000
      else if (key === "username")
        value = params[IG_PARAMS_STRUCTURE.username]
      


      obj[fieldIdObj[key]] = value
    }
    
    list.push({fields: obj})
  }

  return list
}



/**
 * @common(set) {ËØªÂèñÁºìÂ≠òÔºåÂπ∂ËµãÂÄºÁªôÁõ∏ÂÖ≥ÂèòÈáè}
 */
const setVariableFromLocalStorage = () => {

  if (localStorage.getItem('IG_COOKIE') !== null) {  // string Á±ªÂûã
    IG_COOKIE.value = localStorage.getItem('IG_COOKIE')
  }
  if (localStorage.getItem('IG_APP_ID') !== null) {  // string Á±ªÂûã
    IG_APP_ID.value = localStorage.getItem('IG_APP_ID')
  }
  if (localStorage.getItem('IG_CLAIM') !== null) {  // string Á±ªÂûã
    IG_CLAIM.value = localStorage.getItem('IG_CLAIM')
  }
  

  if (localStorage.getItem('targetHashTag') !== null) {  // string Á±ªÂûã
    targetHashTag.value = localStorage.getItem('targetHashTag')
  }

  if (localStorage.getItem('userTableId') !== null) {  // string Á±ªÂûã
    userTableId.value = localStorage.getItem('userTableId')
  }

  if (localStorage.getItem('userFieldId') !== null) {  // string Á±ªÂûã
    userFieldId.value = localStorage.getItem('userFieldId')
  }

  if (localStorage.getItem('postTableId') !== null) {  // string Á±ªÂûã
    postTableId.value = localStorage.getItem('postTableId')
  }

}


/**
 * @common(handle) {Â§ÑÁêÜ checkbox ÂÖ®ÈÄâÁÇπÂáª‰∫ã‰ª∂}
 * @param {boolean} val checkbox ÊòØÂê¶ÂÖ®ÈÄâ
 */
const handleselectAllFieldsChange = (val) => {
  const data = JSON.parse(JSON.stringify(responseFieldsAvaiable.value))
  if (val) {
    for (const item of data)
      responseFieldsSelected.value.push(item.label);
  } else {
    responseFieldsSelected.value = []
  }
  isIndeterminateToMap.value = false
}

/**
 * @common(handle) {Â§ÑÁêÜ checkbox ÁÇπÂáª‰∫ã‰ª∂}
 * @param {array} value 
 */
const handleresponseFieldsSelectedChange = (value) => {
  const checkedCount = value.length
  isSelectAllFields.value = checkedCount === responseFieldsAvaiable.value.length
  isIndeterminateToMap.value = checkedCount > 0 && checkedCount < responseFieldsAvaiable.value.length
  console.log('responseFieldsSelected:', responseFieldsSelected.value)

}

watch(userTableId, async (newValue, oldValue) => {
  if (newValue !== oldValue && newValue) {
    const { table, fieldMetaListByType } = await queryTableAndFieldMetaTypeList(userTableId.value, "Text")
    fieldMetaList.value = fieldMetaListByType
  }
})

onMounted(async () => {
  // ÂàùÂßãÂåñÂãæÈÄâÂ≠óÊÆµ
  console.log("onMounted >> Â∑≤ÈÄâ‰∏≠ÁöÑËøîÂõûÂ≠óÊÆµÊï∞ÁªÑ", responseFieldsSelected.value)

  tableMetaList.value =  await queryBaseTableMetaList()
  

  // ËØªÂèñÁºìÂ≠òÊï∞ÊçÆÔºåÂπ∂ËµãÂÄºÁªôÂèòÈáè
  setVariableFromLocalStorage()


});
    
</script>



<style scoped>

.el-icon svg {
  color: #3370ff !important;
}

</style>
